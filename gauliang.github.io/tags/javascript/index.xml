<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>javascript on Gauliang</title>
    <link>https://gauliang.github.io/tags/javascript/</link>
    <description>Recent content in javascript on Gauliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 13 Sep 2020 20:00:24 +0800</lastBuildDate>
    
	<atom:link href="https://gauliang.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Javascript Promise</title>
      <link>https://gauliang.github.io/blog/2020/promise/</link>
      <pubDate>Sun, 13 Sep 2020 20:00:24 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/promise/</guid>
      <description>JavaScript 是单线程工作，这意味着两段脚本不能同时运行，而是必须一个接一个地运行。 操作其中一项任务会延迟其他任务。您可能已使用事件和回调来解决该问题。 Promise 有点类似于事件侦听器，但有以下两点区别：
 promise 只能成功或失败一次， 而不能成功或失败两次，也不能从成功转为失败或从失败转为成功。 如果 promise 已成功或失败，且您之后添加了成功/失败回调，则将会调用正确的回调，即使事件发生在先也是如此。  Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。
概述 Promise 构造函数包含一个参数，该参数是带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var promise = new Promise(function(resolve, reject) { // do a thing, possibly async, then…  if (/* everything turned out fine */) { resolve(&amp;#34;Stuff worked!&amp;#34;); } else { reject(Error(&amp;#34;It broke&amp;#34;)); } }); promise.</description>
    </item>
    
    <item>
      <title>ECMAScript Modules</title>
      <link>https://gauliang.github.io/blog/2020/es-modules/</link>
      <pubDate>Mon, 07 Sep 2020 17:14:01 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/es-modules/</guid>
      <description>ES6 中首次内置了对模块的支持。从理论上讲，ECMAScript 模块应该在所有 JavaScript 环境中通用。实际上，浏览器仍然是ES模块的主要目标。 默认情况下，模块具有严格模式。
一、export 语法  可以在实体前使用 export 关键字实现导出，也可以通过 export 语句导出； 每个模块中可以有 0 各或者多个具名导出; 每个模块最多可以具有 1 个默认导出，常用于只有一个函数或类的模块； 在 export 子句中，可以通过 as 语法重命名导出； 一个模块可以同时包含具名导出和默认导出，但是通常最好每个模块都采用一种导出样式； 未导出的部分，是模块专有的，不能被外部访问。  1 2 3 4 5 6 7 8 9 10 11 12  // 具名导出 export function func() {} export const number = 1; export {f as foo, bar}; // 默认导出 export default function func() {} export default 618; // 从另一个模块导出 export * from &amp;#39;.</description>
    </item>
    
    <item>
      <title>CommonJS Modules</title>
      <link>https://gauliang.github.io/blog/2020/commonjs-modules/</link>
      <pubDate>Sun, 06 Sep 2020 10:19:40 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/commonjs-modules/</guid>
      <description>CommonJS Modules  在 ES2015（也被称为ES6） 标准之前，JavaScript语言没有模块化组织代码的原生方法，CommonJS 模块格式填补了这一空白。 CommonJS 规范了如何编写模块，以及如何在模块系统之间实现互操作。由于其同步执行特性，CMD 主要用于服务端开发。
 本文代码范例均基于 Node.js (Node.js 模块基于该规范略有不同)。
 模块规范  在模块中，有一个可用的 require 函数。  require 函数接收一个模块标识符 require 函数返回外部模块导出的 API 如果存在依赖循环，则外部模块在其传递依赖要求时可能尚未完成执行；在这种情况下，由 require 返回的对象必须至少包含外部模块在调用要求导致当前模块执行之前准备的导出。 如果要求的模块不能被返回，则 require 必须 throw 一个错误。   在模块中，有一个名为 exports 的自由变量，该变量是模块在执行时可以向其添加 API 的对象。 模块必须使用 exports 对象作为唯一的导出方法。  应用 所有代码都运行在模块作用域，不会污染全局作用域。模块的加载顺序，按照其在代码中的出现顺序。 接下来，我们尝试用 Commonjs 完成一个简单的小应用。在 math.js 中声明一个 CommonJS 模块，并通过 exports 导出名为 add 的方法。
1 2 3 4 5 6 7 8  //math.js exports.add = function() { var sum = 0, i = 0, args = arguments, l = args.</description>
    </item>
    
    <item>
      <title>Javascript 模块化概述</title>
      <link>https://gauliang.github.io/blog/2020/what-are-cjs-amd-umd-and-esm-in-javascript/</link>
      <pubDate>Sat, 05 Sep 2020 16:04:37 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/what-are-cjs-amd-umd-and-esm-in-javascript/</guid>
      <description>当我们提及模块化时，通常意味着是由一组高度分离的，不同的功能块存储在模块中组成的。 在可能的情况下，通过松散耦合消除依赖关系简化应用程序的可维护性。 本文概述集中流行的模块化规范，以便在不同应用场景中能够快速决策选型。
CommonJS CommonJS 是同步导入，主要用于服务器端，无法在浏览器中直接运行。 导入 CJS 时，它将为你提供导入对象的副本，不支持 Tree-shaking。 通过 require 和 exports 与模块系统交互。
1 2 3 4 5 6 7  //importing const doSomething = require(&amp;#39;./doSomething.js&amp;#39;); //exporting module.exports = function doSomething(n) { // do something }   AMD AMD 全称 Asynchronous Module Definition —— 异步模块定义，由 RequireJS 实现，可在浏览器直接使用，语法相对复杂。
1 2 3 4 5 6 7 8 9 10 11 12 13  define([&amp;#39;dep1&amp;#39;, &amp;#39;dep2&amp;#39;], function (dep1, dep2) { //Define the module value by returning a value.</description>
    </item>
    
    <item>
      <title>Javascript 箭头函数最佳实践[译]</title>
      <link>https://gauliang.github.io/blog/2020/javascript-arrow-function-best-practices/</link>
      <pubDate>Sat, 05 Sep 2020 10:51:40 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/javascript-arrow-function-best-practices/</guid>
      <description>Javascript 箭头函数最佳实践   英文原文： 5 Best Practices to Write Quality Arrow Functions
 箭头函数的语法简洁明了，非常适合作为回调使用，这里介绍 5 个有关箭头函数的最佳实践。
一、箭头函数名称推断 JS 中的箭头函数 name 值是一个空字符串，在调试会话或调用堆栈分析期间箭头函数被标记为 anonymous（匿名函数）。 通过函数名称推断（ES2015 的功能）可以在某些条件下检测到函数名称。
1  ( number =&amp;gt; number + 1 ).name; // =&amp;gt; &amp;#39;&amp;#39;   名称推断的思想是 JavaScript 可以从其语法位置确定箭头函数名称：例如，从保存函数对象的变量名称确定。
1 2  const increaseNumber = number =&amp;gt; number + 1; increaseNumber.name; // =&amp;gt; &amp;#39;increaseNumber&amp;#39;   建议： 使用函数名称推断来命名箭头函数。
二、尽可能内联 内联函数是仅具有一个表达式的函数。当箭头函数具有一个表达式时，可以轻松删除花括号 { } 和 return 语句：
1 2 3 4 5 6 7 8 9  const array = [1, 2, 3]; // 建议 array.</description>
    </item>
    
  </channel>
</rss>