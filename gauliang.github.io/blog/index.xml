<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Gauliang</title>
    <link>https://gauliang.github.io/blog/</link>
    <description>Recent content in Blogs on Gauliang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 10 Oct 2020 17:03:29 +0800</lastBuildDate>
    
	<atom:link href="https://gauliang.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Block Formatting Context</title>
      <link>https://gauliang.github.io/blog/2020/block-formatting-context/</link>
      <pubDate>Sat, 10 Oct 2020 17:03:29 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/block-formatting-context/</guid>
      <description>了解 BFC 是什么，它具备什么布局特性，以及如何创建 BFC，有助于深入理解 CSS 布局的工作方式。
什么是 BFC 块格式化上下文(Block Formatting Context) 是一个独立的渲染区域，它指定内部 Block-level Box 的布局方式，并且与该区域的外部无关（无论内部元素如何排列，都不会影响外部元素）。
BFC 布局规则  在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。 两个兄弟盒子之间的垂直距离由&amp;rsquo;margin&amp;rsquo;属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。 在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。  Block Formatting Context  如上图中所看到的，属于块格式上下文的所有盒子都左对齐（对于LTR），并且它们的左外边缘接触包含块的左边缘。在最后一个框中，我们可以看到，即使左侧有一个浮动的元素（棕色），另一个元素（绿色）仍会触及包含块的左侧边距。
如何创建 BFC  Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &amp;lsquo;overflow&amp;rsquo; other than &amp;lsquo;visible&amp;rsquo; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</description>
    </item>
    
    <item>
      <title>Javascript Promise</title>
      <link>https://gauliang.github.io/blog/2020/promise/</link>
      <pubDate>Sun, 13 Sep 2020 20:00:24 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/promise/</guid>
      <description>JavaScript 是单线程工作，这意味着两段脚本不能同时运行，而是必须一个接一个地运行。 操作其中一项任务会延迟其他任务。您可能已使用事件和回调来解决该问题。 Promise 有点类似于事件侦听器，但有以下两点区别：
 promise 只能成功或失败一次， 而不能成功或失败两次，也不能从成功转为失败或从失败转为成功。 如果 promise 已成功或失败，且您之后添加了成功/失败回调，则将会调用正确的回调，即使事件发生在先也是如此。  Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。 本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。
概述 Promise 构造函数包含一个参数，该参数是带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var promise = new Promise(function(resolve, reject) { // do a thing, possibly async, then…  if (/* everything turned out fine */) { resolve(&amp;#34;Stuff worked!&amp;#34;); } else { reject(Error(&amp;#34;It broke&amp;#34;)); } }); promise.</description>
    </item>
    
    <item>
      <title>ECMAScript Modules</title>
      <link>https://gauliang.github.io/blog/2020/es-modules/</link>
      <pubDate>Mon, 07 Sep 2020 17:14:01 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/es-modules/</guid>
      <description>ES6 中首次内置了对模块的支持。从理论上讲，ECMAScript 模块应该在所有 JavaScript 环境中通用。实际上，浏览器仍然是ES模块的主要目标。 默认情况下，模块具有严格模式。
一、export 语法  可以在实体前使用 export 关键字实现导出，也可以通过 export 语句导出； 每个模块中可以有 0 各或者多个具名导出; 每个模块最多可以具有 1 个默认导出，常用于只有一个函数或类的模块； 在 export 子句中，可以通过 as 语法重命名导出； 一个模块可以同时包含具名导出和默认导出，但是通常最好每个模块都采用一种导出样式； 未导出的部分，是模块专有的，不能被外部访问。  1 2 3 4 5 6 7 8 9 10 11 12  // 具名导出 export function func() {} export const number = 1; export {f as foo, bar}; // 默认导出 export default function func() {} export default 618; // 从另一个模块导出 export * from &amp;#39;.</description>
    </item>
    
    <item>
      <title>CommonJS Modules</title>
      <link>https://gauliang.github.io/blog/2020/commonjs-modules/</link>
      <pubDate>Sun, 06 Sep 2020 10:19:40 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/commonjs-modules/</guid>
      <description>CommonJS Modules  在 ES2015（也被称为ES6） 标准之前，JavaScript语言没有模块化组织代码的原生方法，CommonJS 模块格式填补了这一空白。 CommonJS 规范了如何编写模块，以及如何在模块系统之间实现互操作。由于其同步执行特性，CMD 主要用于服务端开发。
 本文代码范例均基于 Node.js (Node.js 模块基于该规范略有不同)。
 模块规范  在模块中，有一个可用的 require 函数。  require 函数接收一个模块标识符 require 函数返回外部模块导出的 API 如果存在依赖循环，则外部模块在其传递依赖要求时可能尚未完成执行；在这种情况下，由 require 返回的对象必须至少包含外部模块在调用要求导致当前模块执行之前准备的导出。 如果要求的模块不能被返回，则 require 必须 throw 一个错误。   在模块中，有一个名为 exports 的自由变量，该变量是模块在执行时可以向其添加 API 的对象。 模块必须使用 exports 对象作为唯一的导出方法。  应用 所有代码都运行在模块作用域，不会污染全局作用域。模块的加载顺序，按照其在代码中的出现顺序。 接下来，我们尝试用 Commonjs 完成一个简单的小应用。在 math.js 中声明一个 CommonJS 模块，并通过 exports 导出名为 add 的方法。
1 2 3 4 5 6 7 8  //math.js exports.add = function() { var sum = 0, i = 0, args = arguments, l = args.</description>
    </item>
    
    <item>
      <title>Javascript 模块化概述</title>
      <link>https://gauliang.github.io/blog/2020/what-are-cjs-amd-umd-and-esm-in-javascript/</link>
      <pubDate>Sat, 05 Sep 2020 16:04:37 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/what-are-cjs-amd-umd-and-esm-in-javascript/</guid>
      <description>当我们提及模块化时，通常意味着是由一组高度分离的，不同的功能块存储在模块中组成的。 在可能的情况下，通过松散耦合消除依赖关系简化应用程序的可维护性。 本文概述集中流行的模块化规范，以便在不同应用场景中能够快速决策选型。
CommonJS CommonJS 是同步导入，主要用于服务器端，无法在浏览器中直接运行。 导入 CJS 时，它将为你提供导入对象的副本，不支持 Tree-shaking。 通过 require 和 exports 与模块系统交互。
1 2 3 4 5 6 7  //importing const doSomething = require(&amp;#39;./doSomething.js&amp;#39;); //exporting module.exports = function doSomething(n) { // do something }   AMD AMD 全称 Asynchronous Module Definition —— 异步模块定义，由 RequireJS 实现，可在浏览器直接使用，语法相对复杂。
1 2 3 4 5 6 7 8 9 10 11 12 13  define([&amp;#39;dep1&amp;#39;, &amp;#39;dep2&amp;#39;], function (dep1, dep2) { //Define the module value by returning a value.</description>
    </item>
    
    <item>
      <title>Javascript 箭头函数最佳实践[译]</title>
      <link>https://gauliang.github.io/blog/2020/javascript-arrow-function-best-practices/</link>
      <pubDate>Sat, 05 Sep 2020 10:51:40 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/javascript-arrow-function-best-practices/</guid>
      <description>Javascript 箭头函数最佳实践   英文原文： 5 Best Practices to Write Quality Arrow Functions
 箭头函数的语法简洁明了，非常适合作为回调使用，这里介绍 5 个有关箭头函数的最佳实践。
一、箭头函数名称推断 JS 中的箭头函数 name 值是一个空字符串，在调试会话或调用堆栈分析期间箭头函数被标记为 anonymous（匿名函数）。 通过函数名称推断（ES2015 的功能）可以在某些条件下检测到函数名称。
1  ( number =&amp;gt; number + 1 ).name; // =&amp;gt; &amp;#39;&amp;#39;   名称推断的思想是 JavaScript 可以从其语法位置确定箭头函数名称：例如，从保存函数对象的变量名称确定。
1 2  const increaseNumber = number =&amp;gt; number + 1; increaseNumber.name; // =&amp;gt; &amp;#39;increaseNumber&amp;#39;   建议： 使用函数名称推断来命名箭头函数。
二、尽可能内联 内联函数是仅具有一个表达式的函数。当箭头函数具有一个表达式时，可以轻松删除花括号 { } 和 return 语句：
1 2 3 4 5 6 7 8 9  const array = [1, 2, 3]; // 建议 array.</description>
    </item>
    
    <item>
      <title>Gitlab CE Work Flow</title>
      <link>https://gauliang.github.io/blog/2020/gitlab-ce-work-flow/</link>
      <pubDate>Sat, 29 Aug 2020 08:09:15 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/gitlab-ce-work-flow/</guid>
      <description>本系列文章旨在整理和规范 Gitlab-CE 在团队协作中的最佳应用建议。内容将覆盖工作流规范、CI、CD、WebHooks、ChatOps、Gitlab API、基础运维等。
一、认领 issue  在项目仓库首页依次打开左侧菜单 Issues / Boards，进入看板页面； 左侧 Open 列表中单击待认领的 Issue，在弹出的 Issue 信息面板中， 将其 Assigness 到自己名下。部分 Issue 会在创建时直接 Assigness 到相关人员，此时则无需再次 Assigness 操作； 把当前 Issue 从左侧 Open 列表移动到 To Do 列表；   注：完成上述操作，页面右上角 To-Do 列表任务数将会加一。
 二、开发  创建分支，打开 Issue 页面，点击 Create merge request 按钮右侧下拉箭头，选择 Create branch，输入分支名称，创建分支。 拉取新创建的分支到本地，开始开发工作。 完成开发后，Push 当前分支代码到 Git 服务端。  三、创建 MR  仓库首页打开 Merge Requests 页面，点击 New merge request 按钮。 选择源分支以及要合并的目标分支，点击 Compare branches and continue。 MR 描述，在&amp;rsquo;Closes #{branch-id}&amp;lsquo;之后空出一行，输入当前 MR 相关的描述信息。 Close #{branch-id} 会确保分支合并后自动关闭相关 Issue，/done确保分支合并后更新 Issue 的 Doing 标签为 Done。 更多 Quick Actions 请参考 GitLab Quick Actions Assignee 参与代码审查的人员。如果需要更多人参与评审，可在MR创建完成后，在其评论区 AT 具体人名参与评审。 在 Merge options 处，选中 Delete source branch when merge request is accepted。如果要在合并到 master 时 压缩 commit 记录，可以选中 Squash commits when merge request is accepted。 Submit merge request 提交  四、代码审查  仓库首页打开 Merge Requests ，列出全部 MR 清单，或通过页面右上角的 Merge requests 按钮打开一个仅包含需要你进行代码审查的MR清单。 选择并打开需要 Review 的 MR 。在 Discussion 界面可以进行沟通，Commits 界面查看当前 MR 源分支上的所有提交，Changes 界面查看 当前 MR 源分支与目标分支的变更对比。 在Changes界面可以通过代码行号左侧的讨论图标对代码提出修改意见，这些修改意见的总数量会在 Changes 页面的 Tab 菜单右侧展示。浏览所有变更 文件，并提出修改意见。 针对 Review 中提出的问题，开发人员需在MR源分支上进行处理，处理后提交分支代码到服务器，在评论区**@ 相关审查人员**继续进行代码评审。 审查人员再次对分支代码进行评审，将已经处理好的修改意见标记为 resolved，参考步骤[3]，对于新出现的问题继续提出修改意见。 循环执行上述步骤 [4-5]，直至分支代码完全符合合并要求。 当 Review 中提出的所有修改意见，全部被标记为 resolved 之后，在 Discussion 界面回复 /LGTM 并 AT Master 分支管理员。 只要满足上述条件，CI 机器人或 Master 管理员会合并MR源分支到目标分支（Master），合并后，相关MR源分支自动删除，issue自动关闭。  五、完成  更新 issue 上的 Doing 标签为 Done。  </description>
    </item>
    
    <item>
      <title>安装和配置 kubectl &amp; istioctl</title>
      <link>https://gauliang.github.io/blog/2020/kubectl-and-istio/</link>
      <pubDate>Sun, 09 Aug 2020 11:13:31 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/kubectl-and-istio/</guid>
      <description>一、Kubectl kubectl 是 Kubernetes 的命令行工具，通过它可以对 Kubernetes 集群执行指定的命令。 通过 kubectl 你可以部署应用，检查和管理集群资源并查看日志等。
1. 安装 kubectl Linux ubuntu 系统
1 2 3  sudo apt install kubectl # 测试 kubectl version --client   Macos 系统
1 2 3  brew install kubectl # 测试 kubectl version --client   2. 配置 kubectl 自动补全 kubectl 为 bash 和 zsh 提供自动补全能力。kubectl completion bash 命令可生成 Bash 的自动补全脚本，该脚本基于 bash-completion，需要线安装该软件。
Linux 系统
1 2 3 4  # 该命令会创建 `/usr/share/bash-completion/bash_completion` sudo apt install bash-completion # 启用kubectl自动补全 echo &amp;#39;source &amp;lt;(kubectl completion bash)&amp;#39; &amp;gt;&amp;gt;~/.</description>
    </item>
    
    <item>
      <title>在 Linux 和 Windows 平台安装 Docker CE</title>
      <link>https://gauliang.github.io/blog/2020/install-docker-engine/</link>
      <pubDate>Wed, 22 Jan 2020 16:32:22 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/install-docker-engine/</guid>
      <description>Docker 是一个用于开发、交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，以与管理应用程序相同的方式来管理基础架构，从而快速交付软件。通过利用 Docker 快速交付、测试和部署代码的方法，您可以大大缩短编写代码和在生产环境中运行代码之间的时间。
Windows 系统安装 windows10 操作系统自带 windows hyper-v 可以非常方便的运行 Docker。 在 windows7 系统上则稍微复杂一点，需通过安装 Docker-Toolbox 来使用 Docker（用 Oracle virtualbox 来取代 Hyper-V）。
 windows 10 安装 Docker for Windows Installer windows 7 安装 Docker Toolbox  安装完成后，要启动 Docker 请从开始菜单打开 Docker for Winodws，window7 系统需打开 Kitematic，Kitematic 提供直观的图形用户界面来运行 Docker 容器。
虽然在 windows7 平台通过 DockerToolbox 可以正常运行 Docker，但使用体验一般，建议迁移到 Linux 平台，debian / ubuntu / fedora 等都是不错的选择。
Linux 系统安装 这里以 Fedora 为例（当前最新版本为 Fedora28），简要整理一下安装过程，其他环境大同小异。
卸载旧版本 如果存在旧版本的 Docker 则将其卸载，不存在可忽略此步骤。</description>
    </item>
    
    <item>
      <title>常用系统 root 密码重置</title>
      <link>https://gauliang.github.io/blog/2020/reset-password/</link>
      <pubDate>Tue, 21 Jan 2020 22:44:48 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/reset-password/</guid>
      <description>1、MySql 5.7 本节介绍如何重置 MySql 5.7 系统 root 用户密码。
首选，以安全模式登录
1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Stop MySQL sudo service mysql stop # Make MySQL service directory. sudo mkdir -p /var/run/mysqld # Give MySQL user permission to write to the service directory. sudo chown mysql:mysql /var/run/mysqld # Start MySQL manually, without permission checks or networking. sudo mysqld_safe --skip-grant-tables &amp;amp; # Log in without a password.</description>
    </item>
    
    <item>
      <title>Ubuntu 18.04 安装 Java 环境 - OpenJDK</title>
      <link>https://gauliang.github.io/blog/2020/how-to-install-java-with-apt-get-on-ubuntu/</link>
      <pubDate>Tue, 21 Jan 2020 00:20:08 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/how-to-install-java-with-apt-get-on-ubuntu/</guid>
      <description>Java 和 JVM（Java 的虚拟机）被广泛使用，本文介绍如何使用 apt-get 安装不同版本的 Open JRE 和 Open JDK。JRE 仅用于提供 Java 应用程序执行环境，如果要编译 Java 应用程序，则要安装 JDK。
先决条件  Ubuntu 18.04 服务器 具有 sudo 或 root 执行权限的账户  安装默认版本 安装 Java 最简单的做法是使用 Ubuntu 系统自带的版本。默认情况下，Ubuntu 18.04 包含 Open JDK，它是 JRE 和 JDK 的开源变体。
1 2 3 4 5  # 更新软件包索引： sudo apt update # 检查是否已安装Java： java -version   如果当前未安装 Java，则会看到以下输出：
1 2  Command &amp;#39;java&amp;#39; not found, but can be installed with: .</description>
    </item>
    
    <item>
      <title>使用 kubeadm 安装单控制平面 Kubernetes 集群</title>
      <link>https://gauliang.github.io/blog/2020/creating-single-control-plane-cluster-with-kubeadm/</link>
      <pubDate>Sun, 19 Jan 2020 20:30:54 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/creating-single-control-plane-cluster-with-kubeadm/</guid>
      <description>部署单控制平面 k8s 集群，并安装 Dashboard 和 ingress-nginx 使外部浏览器可以访问集群。  一、拓扑结构 本文主要介绍如何使用 kubeadm 安装部署单控制平面 Kubernetes v1.17.0 集群，所谓单控制平面，顾名思义就是由一个 Control-plane Node 和多个 Work Node 组成的 Kubernetes 集群。高可用集群与此不同，其由多个 Control-plane Node 和多个 Work Node 组成，高可用集群部署中，根据 etcd 数据库部署位置的不同，又分为栈内 etcd 数据库部署和外部独立 etcd 数据库集群部署两种模式。 下面展示了不同部署模式的拓扑结构：
单控制平面拓扑结构  高可用拓扑结构（栈内 etcd 数据库）  高可用拓扑结构（外部独立 etcd 数据库集群）  高可用部署与单控制平面部署不同，不过，除负载均衡及多 kube-apiserver 部分外，其他流程大同小异。有关高可用安装的更多信息请参考 Creating Highly Available clusters with kubeadm。
二、准备工作 硬件要求，建议 4 核以上 CPU，8GB 以上内存，Ubuntu 16.04 以上或 CentOS 7 以上版本的操作系统，确保所有服务器间网络通信正常，1 台服务器作为控制平面节点，其余若干台服务器作为工作节点，我这里准备了4个工作节点。基本信息如下：
   名称 CPU 内存 IP OS 安装 用途     CPN-1 4U 8GB 10.</description>
    </item>
    
    <item>
      <title>微服务 API 网关 KrakenD</title>
      <link>https://gauliang.github.io/blog/2020/microservice-api-gateway-krakend/</link>
      <pubDate>Sat, 11 Jan 2020 15:28:13 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/microservice-api-gateway-krakend/</guid>
      <description>KrakenD 是用 Go 编写的开源高性能无状态、分布式、微服务 API 网关，其不仅可以轻松将客户端请求转发到后端服务，还具备强大的数据处理功能，支持转换、过滤、聚合和修剪来自后端服务甚至第三方服务的返回数据，从而消除处理多个 REST 服务的必要性，使客户端与微服务的实现细节隔离开来。这一切通过简单的配置即可实现，本文介绍 KrakendD 如何安装部署并快速投入应用。
KrakenD 概述 KrakenD 在具备超高性能的基础上还提供丰富的功能，简要梳理：
 API 数据聚合，将来自多个 API 的数据聚合到一起。 API 数据过滤，仅公开真正需要的数据。 强大的配置模板，且支持多种配置格式，但建议使用 JSON 配置，可以实现更加灵活的网关配置。 无状态、无数据库，在 KrakenD 群集中，所有节点都是自治的，即使关闭了所有其他节点，其仍可继续运行。 支持在几乎所有环境中运行，无论是虚拟机或容器云环境。 支持插件扩展，您可以使用 Go 或 Lua 脚本扩展 KrakenD 功能和业务逻辑。 接口安全，支持速率限制、OAuth、SSL、XSS防护等多种安全策略，且均为开箱即用。 机器人探测器  更多功能特性请参考官网文档 krakenD
基于 Kubernetes 部署高可用 KrakenD 集群 KrakenD 是一个独立的二进制文件，可直接运行，不需要任何外部库工作。本节介绍在 Kubernetes 环境安装 KrakenD 的大致步骤。
配置文件 KrakenD 服务器启动和操作所需的所有配置都在配置文件中定义，可以通过可视化工具 KrakenDesigner 生成，可用的常用配置文件格式有 .json，.toml 和 .yaml。配置文件写好后，可以通过 krakend check 进行语法检查。
1、语法检查
1 2  $ krakend check --config .</description>
    </item>
    
    <item>
      <title>ubuntu 开发环境备忘指南</title>
      <link>https://gauliang.github.io/blog/2020/ubuntu-handbook/</link>
      <pubDate>Sat, 21 Dec 2019 23:20:31 +0800</pubDate>
      
      <guid>https://gauliang.github.io/blog/2020/ubuntu-handbook/</guid>
      <description>一、基本系统设置 1 2 3 4 5 6  # 1. 移除桌面图标显示 sudo apt remove gnome-shell-extension-desktop-icons # 2. 移除桌面边栏菜单 sudo apt remove gnome-shell-extension-ubuntu-dock   当前系统链接多个显示器，在桌面空间切换时，默认仅切换主显示器，如需同步切换，可通过安装 gnome-tweaks 软件 ，在 Workspaces 菜单下 Display Handling 项选择 Workspaces span displays 即可。
1 2  sudo apt install gnome-tweaks gnome-tweaks   安装 GNOME Shell Extension Hide Top Bar 可配置自动隐藏桌面顶部状态栏。
二、开发环境配置 1. 安装 Nodejs 参考 https://github.com/nodejs/help/wiki/Installation 下载二进制文件完成安装。</description>
    </item>
    
  </channel>
</rss>